((3) 0 () 3 ((p+ #"/home/bill/Desktop/billpcs.github.io/_src/posts/2017-05-20-abstraction-through-an-example.md" . unix) (p+ #"/home/bill/Desktop/billpcs.github.io/_src/posts/2016-12-16-test-blog-post.md" . unix) (p+ #"/home/bill/Desktop/billpcs.github.io/_src/posts/2018-03-25-sdes-in-scala.md" . unix)) () (h ! (equal) ((p+ #"/home/bill/Desktop/billpcs.github.io/_src/posts/2016-12-16-test-blog-post.md" . unix) f post (u . "The first blog post") (? . 1) 1521984011 (p+ #"/home/bill/Desktop/billpcs.github.io/2016/12/the-first-blog-post.html" . unix) (u . "/2016/12/the-first-blog-post.html") (u . "2016-12-16T17:07:17") #f (? . 0) (c (u . "ip") c (u . "scala") c (u . "python")) (u . "\n<h3 id=\"undestanding--by-doing-something-else\">Undestanding <a href=\"https://github.com/greghendershott/frog\"><strong><em>frog</em></strong></a> (by doing something else)</h3>\n\n<p>I will try to write a function to convert a bit-stream (in the form of a string) to its representation as an <a href=\"https://en.wikipedia.org/wiki/IP_address#IPv4_addresses\">IPv4</a> address.</p>\n\n<p>The catch is, the code must be as concise as possible.</p>") #t (u . "\n<h3 id=\"undestanding--by-doing-something-else\">Undestanding <a href=\"https://github.com/greghendershott/frog\"><strong><em>frog</em></strong></a> (by doing something else)</h3>\n\n<p>I will try to write a function to convert a bit-stream (in the form of a string) to its representation as an <a href=\"https://en.wikipedia.org/wiki/IP_address#IPv4_addresses\">IPv4</a> address.</p>\n\n<p>The catch is, the code must be as concise as possible.</p>\n<!-- more-->\n\n<p><strong><em>Let&rsquo;s try Scala!</em></strong></p>\n\n<p>Scala can be very concise and yet readable with some nicely written chains of operations. Let&rsquo;s see it in action here:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"k\">def</span> <span class=\"n\">toIp</span><span class=\"o\">(</span><span class=\"n\">str</span><span class=\"k\">:</span> <span class=\"kt\">String</span><span class=\"o\">)</span> <span class=\"k\">=</span>\n     <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"n\">grouped</span><span class=\"o\">(</span><span class=\"mi\">8</span><span class=\"o\">)</span>\n        <span class=\"o\">.</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">el</span> <span class=\"k\">=&gt;</span> <span class=\"nc\">Integer</span><span class=\"o\">.</span><span class=\"n\">parseInt</span><span class=\"o\">(</span><span class=\"n\">el</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">))</span>\n        <span class=\"o\">.</span><span class=\"n\">mkString</span><span class=\"o\">(</span><span class=\"s\">\".\"</span><span class=\"o\">)</span>   \n</pre></div>\n\n</div>\n\n<p>The <code>grouped(n)</code> method is defined for all the members of <code>scala.collection.IterableLike</code> which <code>String</code> is a member of. But let&rsquo;s not get too involved.</p>\n\n<p>What it does is given <strong>&ldquo;123456&rdquo;</strong> return an iterator with the contents grouped every <strong><em>nth</em></strong> character, i.e if n is 2 then we get <code>(\"12\", \"34\", \"56\")</code> which is perfect for this job.</p>\n\n<p>All we have to do then, is map each one to its decimal representation and be done with it.</p>\n\n<p>Now we can just say</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"k\">@</span> <span class=\"n\">toIp</span><span class=\"o\">(</span><span class=\"s\">\"10000000000010100000001000011110\"</span><span class=\"o\">)</span>\n  <span class=\"n\">res1</span><span class=\"k\">:</span> <span class=\"kt\">String</span> <span class=\"o\">=</span> <span class=\"s\">\"128.10.2.30\"</span>\n</pre></div>\n\n</div>\n\n<p><strong><em>Let&rsquo;s try Python!</em></strong></p>\n\n<p>The best way I could come up with, without making and import, is this</p>\n\n<div class=\"brush: python\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"k\">def</span> <span class=\"nf\">to_ip</span><span class=\"p\">(</span><span class=\"n\">bitstr</span><span class=\"p\">):</span>\n    <span class=\"n\">lst</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">bitstr</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">8</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">bitstr</span><span class=\"p\">),</span> <span class=\"mi\">8</span><span class=\"p\">)]</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">lst</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"s1\">&#39;.&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span>\n</pre></div>\n\n</div>\n\n<p>and then you can simply call</p>\n\n<div class=\"brush: python\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">to_ip</span><span class=\"p\">(</span><span class=\"s2\">\"10000000000010100000001000011110\"</span><span class=\"p\">))</span>\n  <span class=\"mf\">128.10</span><span class=\"o\">.</span><span class=\"mf\">2.30</span>\n</pre></div>\n\n</div>\n\n<p>But one would argue that python is no good without the imports. And I agree, so let&rsquo;s try the same thing, but now with the help of an import.</p>\n\n<div class=\"brush: python\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"kn\">import</span> <span class=\"nn\">re</span>\n  <span class=\"k\">def</span> <span class=\"nf\">to_ip2</span><span class=\"p\">(</span><span class=\"n\">bitstr</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s1\">&#39;.&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">findall</span><span class=\"p\">(</span><span class=\"s1\">&#39;........?&#39;</span><span class=\"p\">,</span> <span class=\"n\">bitstr</span><span class=\"p\">)])</span>\n</pre></div>\n\n</div>\n\n<p>so now we can call it again and get the expected results</p>\n\n<div class=\"brush: python\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">to_ip2</span><span class=\"p\">(</span><span class=\"s2\">\"10000000000010100000001000011110\"</span><span class=\"p\">))</span>\n  <span class=\"mf\">128.10</span><span class=\"o\">.</span><span class=\"mf\">2.30</span>\n</pre></div>\n\n</div>\n\n<p>This is quite concise but it becomes difficult to read.</p>\n\n<p>The classic readability/conciseness problem.</p>\n\n<p>I would argue that it is much clearer in Scala, without giving way to less conciseness.</p>")) ((p+ #"/home/bill/Desktop/billpcs.github.io/_src/posts/2017-05-20-abstraction-through-an-example.md" . unix) f post (u . "The Power Of Abstraction") (? . 0) 1521984011 (p+ #"/home/bill/Desktop/billpcs.github.io/2017/05/the-power-of-abstraction.html" . unix) (u . "/2017/05/the-power-of-abstraction.html") (u . "2017-05-20T21:34:27") (? . 1) (? . 2) (c (u . "theory")) (u . "\n<h3 id=\"a-simple-demonstration\">A simple demonstration</h3>\n\n<p>You are outside a restaurant. You get in and sit at a table. The waiter brings you the menu and you choose a steak. You tell the waiter about your decision and after some time (hopefully not too much) the waiter brings a steak to your table. You eat the steak and leave.</p>") #t (u . "\n<h3 id=\"a-simple-demonstration\">A simple demonstration</h3>\n\n<p>You are outside a restaurant. You get in and sit at a table. The waiter brings you the menu and you choose a steak. You tell the waiter about your decision and after some time (hopefully not too much) the waiter brings a steak to your table. You eat the steak and leave.</p>\n<!-- more-->\n\n<p><strong>To really understand what powerful a concept abstraction is, let&rsquo;s examine how your night would have changed if abstractions were non existent.</strong></p>\n\n<p>You are outside a restaurant. You get in and sit at a table. You wait for the waiter to come and bring you a menu, but after about 5 minutes you loose your patience. You get up and try to find a menu yourself. After spending a couple of minutes searching you realize there are no menus lying around. &ldquo;Anyway&rdquo;, you think, &ldquo;I already know what I want, I will have a steak&rdquo;. You look around to find the waiter and inform him about your choice. But of course, you have seen no waiter from the time you came in. It has been a long time since you last had a meal so, hungry as you are, you decide to visit the kitchen and tell them yourself about your steak. Frustrated, you storm in only in your amazement, to find no one there. You are truly puzzled by now. But you are more hungry than puzzled so you open the kitchen fridge.</p>\n\n<p>You get the idea. This can go further and further. You could open the fridge only to find it empty. Because there is no one to supply the steaks to the restaurant. You have to drive on your own to the farm, raise your own animals. Feed them on your own and find their food on your own.</p>\n\n<p>You could go as far as to say that you would have to make your own forks, your own chairs, your own fridges, your own trucks, your own stables. Because nothing is made for you. You would have to reach the bare metal to imagine an end to this chain.</p>\n\n<p><strong>Did you notice? The raw materials are there, they are not missing! It is just that there is nobody to abstract them in order to reach you.</strong></p>\n\n<h3 id=\"so-here-is-how-abstraction-works-in-this-context\">So here is how abstraction works in this context.</h3>\n\n<p>You don&rsquo;t care how the waiter will pass on your order to the kitchen. It could be by words, by a piece of paper, or by an App on his smart-phone. As long as he does it correctly you don&rsquo;t mind. The waiter on his part, does not care how the kitchen master will cook the steak. He could have his assistants do it, he could do it by himself, use that or the other recipe. The cook is only constrained by what this piece of paper says he has to prepare. When he finishes the dish, he just places it in a special place where the waiter can find it and deliver it to you. In much the same way, we can move down the chain.The cook doesn&rsquo;t care how the meat got in the kitchen, as long as it meets his standards, the driver that brought it doesn&rsquo;t care what kind of meat the box contains, or how it was made, as long as he delivers to the recipient labeled on the box. Moving further down, the meat company CEO has no interest in knowing the specifics of this meat order by the restaurant, as long as his company complies with health and quality standards and there is someone to do the distribution.</p>\n\n<p><strong>See the pattern? Nobody has to know how anyone above or below him/her works. The only trait needed is to know how to interact with them.</strong></p>\n\n<p>One could write endless pages thinking about abstractions and relations in our daily world. But let me stop here.</p>\n\n<ul>\n <li>\n  <p>The above example may seem obvious. And I will argue that it is. <strong>But only because this pyramid of duties had time to adapt throughout the human history. The challenge comes when you need to scale a system like a company, a product or a protocol with no errors and in little to no time.</strong></p></li>\n <li>\n  <p>My goal is to write some follow ups to this post analyzing some of the greatest incarnations of abstractions in technology in todays world.</p></li></ul>")) ((p+ #"/home/bill/Desktop/billpcs.github.io/_src/posts/2018-03-25-sdes-in-scala.md" . unix) f post (u . "SDES in Scala") (? . 2) 1521984318 (p+ #"/home/bill/Desktop/billpcs.github.io/2018/03/sdes-in-scala.html" . unix) (u . "/2018/03/sdes-in-scala.html") (u . "2018-03-25T16:22:29") (? . 0) #f (c (u . "scala") c (u . "cryptography")) (u . "\n<h1 id=\"implementing-simplified-data-encryption-standard-in-scala\">Implementing Simplified Data Encryption Standard in Scala</h1>\n\n<p><em>(I intended for this blog post to be a full explanation of my SDES implementation, but it got too long too fast. Therefore, in this post I focused mostly on the binary number representation and didn&rsquo;t analyze other topics such as the test suite and the class hierarchies, topics that I will maybe address in a future post &mdash;probably never)</em></p>\n\n<h3 id=\"intro\">Intro</h3>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Data_Encryption_Standard\">DES</a> is a symmetric algorithm for encrypting data. Simplified DES or SDES, as I will refer to it from now on, is a simple version of DES, which is used to familiarize the students with the inner workings of the algorithm without getting too involved with details. I happened to implement it for a semester course project and below are some of my thoughts.</p>") #t (u . "\n<h1 id=\"implementing-simplified-data-encryption-standard-in-scala\">Implementing Simplified Data Encryption Standard in Scala</h1>\n\n<p><em>(I intended for this blog post to be a full explanation of my SDES implementation, but it got too long too fast. Therefore, in this post I focused mostly on the binary number representation and didn&rsquo;t analyze other topics such as the test suite and the class hierarchies, topics that I will maybe address in a future post &mdash;probably never)</em></p>\n\n<h3 id=\"intro\">Intro</h3>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Data_Encryption_Standard\">DES</a> is a symmetric algorithm for encrypting data. Simplified DES or SDES, as I will refer to it from now on, is a simple version of DES, which is used to familiarize the students with the inner workings of the algorithm without getting too involved with details. I happened to implement it for a semester course project and below are some of my thoughts.</p>\n<!-- more-->\n\n<h3 id=\"what-i-wanted-to-do-differently\">What I wanted to do differently</h3>\n\n<p>One of the first things I had to consider was how the binary numbers were going to be dealt with internally. Programming languages don&rsquo;t usually have variable types for &ldquo;Bit&rdquo;. The variable type with the smallest amount of memory you can generally get is a Byte. SDES uses binary numbers of three sizes: <strong>4</strong>, <strong>8</strong> and <strong>10 bit</strong> numbers.</p>\n\n<p>What I came across regularly when browsing solutions on SDES was people saving binary numbers as arrays of integers, meaning saving 1&rsquo;s and 0&rsquo;s in an array. I didn&rsquo;t like this approach for various reasons. Firstly, it wastes too much space. This is because, even though we save the information of <strong>one</strong> bit in one array cell, it takes the space of at least 8 bits, if we decide to make it an Array[Byte] (and this is the best we can do in terms of memory with this type). This also means that we have to implement bitwise operations that are used extensively in SDES, from scratch. A <em>bitwise xor</em> for example would probably have to be implemented as presented below:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"k\">type</span> <span class=\"kt\">Binary</span> <span class=\"o\">=</span> <span class=\"nc\">Array</span><span class=\"o\">[</span><span class=\"kt\">Byte</span><span class=\"o\">]</span>\n<span class=\"k\">def</span> <span class=\"n\">xor</span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"k\">:</span> <span class=\"kt\">Binary</span><span class=\"o\">,</span> <span class=\"n\">ys</span><span class=\"k\">:</span> <span class=\"kt\">Binary</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Binary</span> <span class=\"o\">=</span>\n    <span class=\"k\">for</span> <span class=\"o\">{</span>\n      <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">&lt;-</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">zip</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n    <span class=\"o\">}</span> <span class=\"k\">yield</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">^</span> <span class=\"n\">b</span><span class=\"o\">).</span><span class=\"n\">toByte</span>\n</pre></div>\n\n</div>\n\n<p>Let&rsquo;s break up the above function.</p>\n\n<p>The first line just says <em>&ldquo;Instead of me writing <code>Array[Byte]</code> all the time, from now on I will refer to it as <code>Binary</code>&rdquo;</em>. This way the function is more readable and shorter. In other words, <code>Binary</code> is an <em>alias</em> for <code>Array[Byte]</code>.</p>\n\n<p>Then we define the function <code>xor</code>, which receives two binary numbers (of type <code>Binary</code>) and outputs a third one, as should a <em>xor</em> function do. Internally, it zips the two arrays, creating an array of pairs, which then takes one by one and yields the result using the <code>^</code> function defined for <code>Byte</code>.</p>\n\n<p>The <em>xor</em> function <code>^</code> is in reality a bitwise operator and because the array contains only 1&rsquo;s and 0&rsquo;s, it works as expected and produces correct results.</p>\n\n<p>Notice that the running time of the above function is linear and depends on length of the array, i.e the number of bits, as we have to pass through the whole array and <code>xor</code> the elements one by one. This is another reason I don&rsquo;t like this solution.</p>\n\n<h3 id=\"my-solution\">My Solution</h3>\n\n<p>So, after noting these two problems, I started thinking about a different solution. In order for <code>xor</code> operations to execute in almost constant time, we could have <strong>the whole binary number saved in a Short integer</strong>. In this way the operation can be done in one go. With a single <code>^</code> we can have the result of what previously we created a O(n) function for. A <code>Short</code> can be 16bits, which means we can save the 4, 8 and 10 bit numbers we need, in a single <em>Short</em>. With this approach we kill two birds with one stone, as we also solve the problem of using too much memory. Let&rsquo;s see why.</p>\n\n<h4 id=\"memory\">Memory</h4>\n\n<p>For starters, let&rsquo;s examine the impact on the memory usage for storing a 4bit number in these two cases.</p>\n\n<p>In the case of the <code>Array[Byte]</code> we would have 4 elements, each with a size of a <code>Byte</code> meaning 4*8 = 32 bits.</p>\n\n<p>In the second case we would use a Short to store the 4bit number, meaning 16 bits.</p>\n\n<p>In the case of 10bit numbers, the first way yields <em>80 bits</em> and the second stays the same: 16 bits. We can thus see, that even in the worst case, the second way uses less memory.</p>\n\n<p>With some <a href=\"https://www.youtube.com/watch?v=X09oxyIeGuY\">quick maths</a>, for the worst case we get 50% less memory usage and for the best case 80% less memory usage.</p>\n\n<h5 id=\"speed\">Speed</h5>\n\n<p>For bitwise operations we should get a ~4x to 10x speedup (depending on which binary size is the mean). But not everything in the algorithm is about bitwise operations so this figure should be much much lower when executing a whole cycle of the algorithm.</p>\n\n<p>After running some benchmarks, using <a href=\"https://scalameter.github.io/\">Scalameter</a>, it turns out that the second approach gives a <strong>~2x speedup</strong>. Before seeing how this number came out to be, we should first take closer a look at some key elements of my implementation and then contrast it with how this would change for the &ldquo;array way&rdquo; of looking at binary numbers.</p>\n\n<p>For simplicity, we are going to consider the 4 bit case.The other two cases (8 and 10 bit) are almost the same, having only minor differences.</p>\n\n<h5 id=\"bit4\">Bit4</h5>\n\n<p>I decided to call the class which is going to contain the information for a 4 bit number <code>Bit4</code>. So let&rsquo;s start with a constructor.</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Bit4</span><span class=\"o\">(</span><span class=\"k\">val</span> <span class=\"n\">v</span><span class=\"k\">:</span> <span class=\"kt\">Short</span><span class=\"o\">)</span>\n</pre></div>\n\n</div>\n\n<p>Then, have to implement the <code>xor</code> method:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Bit4</span><span class=\"o\">(</span><span class=\"k\">val</span> <span class=\"n\">v</span><span class=\"k\">:</span> <span class=\"kt\">Short</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"k\">def</span> <span class=\"o\">|^|(</span><span class=\"n\">that</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span><span class=\"o\">)</span> <span class=\"k\">=</span>\n    <span class=\"nc\">Bit4</span><span class=\"o\">((</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">v</span> <span class=\"o\">^</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"n\">v</span><span class=\"o\">).</span><span class=\"n\">toShort</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n\n</div>\n\n<p>But this is wrong! We only want the 4 LSB of the value <code>v</code> to be accounted for in the result. By doing this we get values greater than the range a 4 bit number could have. Since numbers are represented in <code>two's complement</code> format, the range for 4 bits is [&ndash;8 to 7]. So, how can we solve this problem?</p>\n\n<h5 id=\"bit-masks-to-the-rescue\">Bit masks to the rescue!</h5>\n\n<p>I really don&rsquo;t know if there is a better way, but here is what I did.</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Bit4</span><span class=\"o\">(</span><span class=\"k\">private</span> <span class=\"k\">val</span> <span class=\"n\">v</span><span class=\"k\">:</span> <span class=\"kt\">Short</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n  <span class=\"k\">val</span> <span class=\"n\">value</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(((</span><span class=\"n\">v</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mh\">0xFFFFFFF0</span> <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xF</span><span class=\"o\">)).</span><span class=\"n\">toShort</span>\n    <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xF</span><span class=\"o\">).</span><span class=\"n\">toShort</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"k\">def</span> <span class=\"o\">|^|(</span><span class=\"n\">that</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span><span class=\"o\">)</span> <span class=\"k\">=</span>\n    <span class=\"nc\">Bit4</span><span class=\"o\">((</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">^</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">).</span><span class=\"n\">toShort</span><span class=\"o\">)</span>\n<span class=\"o\">}</span>\n</pre></div>\n\n</div>\n\n<p>What the above code does is check whether we need to do a sign extension with ones, i.e checks if the MSB is one. If it is, we mask the 4 LSB and sign extend the rest. If it is not, we just mask the 4 LSB. This way, whatever the input value to the constructor, the <code>value</code> will always contain a number in the correct range. If the initial element was not in the correct range, then it is a problem of the caller. I have made the decision not to report anything back or throw an exception.</p>\n\n<p>The final code for <code>Bit4</code> looks something like this:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"k\">case</span> <span class=\"k\">class</span> <span class=\"nc\">Bit8</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span> <span class=\"k\">extends</span> <span class=\"nc\">BinaryNum</span> <span class=\"o\">{</span>\n  <span class=\"k\">def</span> <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"k\">:</span> <span class=\"kt\">String</span><span class=\"o\">)</span> <span class=\"k\">=</span> <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"nc\">Integer</span><span class=\"o\">.</span><span class=\"n\">parseInt</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">).</span><span class=\"n\">toShort</span><span class=\"o\">)</span>\n\n  <span class=\"k\">def</span> <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">ar</span><span class=\"k\">:</span> <span class=\"kt\">Array</span><span class=\"o\">[</span><span class=\"kt\">Bit</span><span class=\"o\">])</span> <span class=\"k\">=</span> <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">ar</span><span class=\"o\">.</span><span class=\"n\">mkString</span><span class=\"o\">)</span>\n\n  <span class=\"c1\">// consider the input as a 4bit two&#39;s complement</span>\n  <span class=\"c1\">// so do sign extension as required</span>\n  <span class=\"k\">val</span> <span class=\"n\">value</span> <span class=\"k\">=</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(((</span><span class=\"n\">v</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x1</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mh\">0xFFFFFFF0</span> <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xF</span><span class=\"o\">)).</span><span class=\"n\">toShort</span>\n    <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xF</span><span class=\"o\">).</span><span class=\"n\">toShort</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"k\">override</span> <span class=\"k\">def</span> <span class=\"n\">apply</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"k\">:</span> <span class=\"kt\">Int</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Bit</span> <span class=\"o\">=</span> <span class=\"nc\">Bit</span><span class=\"o\">(((</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">&gt;&gt;</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">-</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x1</span><span class=\"o\">).</span><span class=\"n\">toByte</span><span class=\"o\">)</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"k\">:</span> <span class=\"kt\">Short</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Short</span><span class=\"o\">)</span> <span class=\"k\">=</span> <span class=\"nc\">Bit4</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">))</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">flatMap</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"k\">:</span> <span class=\"kt\">Short</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Bit4</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">)</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">map2</span><span class=\"o\">(</span><span class=\"n\">that</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span><span class=\"o\">)(</span><span class=\"n\">f</span><span class=\"k\">:</span> <span class=\"o\">(</span><span class=\"kt\">Short</span><span class=\"o\">,</span> <span class=\"kt\">Short</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"nc\">Short</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span> <span class=\"o\">=</span> <span class=\"k\">for</span> <span class=\"o\">{</span>\n    <span class=\"n\">a</span> <span class=\"k\">&lt;-</span> <span class=\"k\">this</span>\n    <span class=\"n\">b</span> <span class=\"k\">&lt;-</span> <span class=\"n\">that</span>\n  <span class=\"o\">}</span> <span class=\"k\">yield</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n  <span class=\"k\">def</span> <span class=\"o\">|^|(</span><span class=\"n\">that</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">map2</span><span class=\"o\">(</span><span class=\"n\">that</span><span class=\"o\">)(</span><span class=\"k\">_</span> <span class=\"o\">^</span> <span class=\"k\">_</span> <span class=\"n\">toShort</span><span class=\"o\">)</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">toBits</span><span class=\"k\">:</span> <span class=\"kt\">Array</span><span class=\"o\">[</span><span class=\"kt\">Bit</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"n\">to</span> <span class=\"mi\">4</span><span class=\"o\">).</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"k\">this</span> <span class=\"o\">(</span><span class=\"k\">_</span><span class=\"o\">)).</span><span class=\"n\">toArray</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">binary</span> <span class=\"k\">=</span> <span class=\"n\">intTo8BitString</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"n\">drop</span> <span class=\"mi\">4</span>\n\n  <span class=\"k\">def</span> <span class=\"n\">concat</span><span class=\"o\">(</span><span class=\"n\">that</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Bit8</span> <span class=\"o\">=</span> <span class=\"nc\">Bit8</span><span class=\"o\">(((</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">&lt;&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">|</span> <span class=\"o\">(</span><span class=\"n\">that</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xF</span><span class=\"o\">)).</span><span class=\"n\">toByte</span><span class=\"o\">)</span>\n\n  <span class=\"k\">override</span> <span class=\"k\">def</span> <span class=\"n\">equals</span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"k\">:</span> <span class=\"kt\">scala.Any</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Boolean</span> <span class=\"o\">=</span> <span class=\"n\">o</span> <span class=\"k\">match</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"n\">x</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span> <span class=\"o\">=&gt;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">value</span>\n    <span class=\"k\">case</span> <span class=\"k\">_</span> <span class=\"k\">=&gt;</span> <span class=\"kc\">false</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n\n</div>\n\n<p>I have just made two auxiliary constructors for creating a Bit4 by passing a binary string (e.g Bit4(&ldquo;0010&rdquo;)) or by passing an array of bits. I also made the class a <em><strong>case class</strong></em> and added an <code>apply</code> method. Without the case class (or a companion object) you would have to write <code>new Bit4(4)</code> when creating instances. What Scala allows with case classes is to remove the need for the <code>new</code> keyword. We can simply write <code>Bit4(10)</code> and create instances throughout the code base. The way the <code>apply</code> method is implemented allows for this kind of syntax:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"n\">scala</span><span class=\"o\">&gt;</span> <span class=\"k\">val</span> <span class=\"n\">num</span> <span class=\"k\">=</span> <span class=\"n\">sdes</span><span class=\"o\">.</span><span class=\"nc\">Bit4</span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">)</span>\n<span class=\"n\">num</span><span class=\"k\">:</span> <span class=\"kt\">sdes.Bit4</span> <span class=\"o\">=</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"n\">b0100</span><span class=\"o\">)</span>\n\n<span class=\"n\">scala</span><span class=\"o\">&gt;</span> <span class=\"n\">num</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">res0</span><span class=\"k\">:</span> <span class=\"kt\">sdes.Bit</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n</pre></div>\n\n</div>\n\n<p>Because many times, during the execution of the algorithm we need to extract a certain bit out of the binary number, this method allows as to do so easily. For instance, if we want to get the second bit as in the above example (counting from the MSB) we just need to call <code>num(2)</code> and we will get <code>1</code> as expected. We could have easily made a method called <code>getBit(n: Int): Bit</code>, but to me, the usage of apply here makes the Bit4 class a seem more like a list of bits.</p>\n\n<p>BinaryNum is just a base trait for all the classes (Bit4, Bit8 and Bit10).</p>\n\n<p>That&rsquo;s all.</p>\n\n<h4 id=\"the-benchmark\">The benchmark</h4>\n\n<p>I wanted to see if my reasoning for choosing this method was correct and there was indeed a remarkable performance penalty when using arrays to represent binary numbers.</p>\n\n<p>In order to test the performance, I had to make some changes and the main such change was made to the |^| function (the <code>concat</code> and <code>split</code> functions also needed to be changed, but you can check them out yourself).</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span>  <span class=\"c1\">// ....</span>\n\n  <span class=\"k\">lazy</span> <span class=\"k\">val</span> <span class=\"n\">bvalue</span> <span class=\"k\">=</span> <span class=\"n\">toBits</span>\n\n  <span class=\"k\">def</span> <span class=\"o\">|^|(</span><span class=\"n\">that</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Bit4</span> <span class=\"o\">=</span>\n    <span class=\"nc\">Bit4</span><span class=\"o\">((</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"n\">bvalue</span> <span class=\"n\">zip</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"n\">bvalue</span><span class=\"o\">).</span><span class=\"n\">map</span><span class=\"o\">{</span>\n      <span class=\"k\">case</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span>  <span class=\"nc\">Bit</span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">^</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">).</span><span class=\"n\">toByte</span><span class=\"o\">)</span>\n    <span class=\"o\">})</span>\n\n  <span class=\"c1\">// ...</span>\n</pre></div>\n\n</div>\n\n<p>I ran the following code using Scalameter</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"k\">import</span> <span class=\"nn\">org.scalameter.api._</span>\n\n<span class=\"k\">object</span> <span class=\"nc\">RangeBenchmark</span> <span class=\"k\">extends</span> <span class=\"nc\">Bench</span><span class=\"o\">.</span><span class=\"nc\">ForkedTime</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">ranges</span> <span class=\"k\">=</span> <span class=\"k\">for</span> <span class=\"o\">{</span>\n    <span class=\"n\">size</span> <span class=\"k\">&lt;-</span> <span class=\"nc\">Gen</span><span class=\"o\">.</span><span class=\"n\">range</span><span class=\"o\">(</span><span class=\"s\">\"size\"</span><span class=\"o\">)(</span><span class=\"mi\">1000</span><span class=\"o\">,</span> <span class=\"mi\">2000</span><span class=\"o\">,</span> <span class=\"mi\">100</span><span class=\"o\">)</span>\n  <span class=\"o\">}</span> <span class=\"k\">yield</span> <span class=\"mi\">0</span> <span class=\"n\">until</span> <span class=\"n\">size</span>\n\n  <span class=\"k\">val</span> <span class=\"n\">encdec</span> <span class=\"k\">=</span> <span class=\"n\">sdes</span><span class=\"o\">.</span><span class=\"nc\">SDES</span><span class=\"o\">(</span><span class=\"mi\">12</span><span class=\"o\">)</span>\n\n  <span class=\"k\">val</span> <span class=\"n\">m</span> <span class=\"k\">=</span> <span class=\"n\">measure</span> <span class=\"n\">method</span> <span class=\"s\">\"encrypt/decrypt\"</span> <span class=\"n\">in</span> <span class=\"o\">{</span>\n    <span class=\"n\">using</span><span class=\"o\">(</span><span class=\"n\">ranges</span><span class=\"o\">)</span> <span class=\"n\">in</span> <span class=\"o\">{</span>\n      <span class=\"k\">_</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">el</span> <span class=\"k\">=&gt;</span> <span class=\"n\">encdec</span><span class=\"o\">.</span><span class=\"n\">decryptByte</span><span class=\"o\">(</span><span class=\"n\">encdec</span><span class=\"o\">.</span><span class=\"n\">encryptByte</span><span class=\"o\">(</span><span class=\"n\">el</span><span class=\"o\">.</span><span class=\"n\">toByte</span><span class=\"o\">)))</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</pre></div>\n\n</div>\n\n<p>The results in milliseconds rounded to the nearest integer are given below:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"c1\">// xor with array</span>\n<span class=\"k\">val</span> <span class=\"n\">xor_ar</span> <span class=\"k\">=</span> <span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"mi\">45</span><span class=\"o\">,</span> <span class=\"mi\">51</span><span class=\"o\">,</span> <span class=\"mi\">55</span><span class=\"o\">,</span> <span class=\"mi\">59</span><span class=\"o\">,</span> <span class=\"mi\">64</span><span class=\"o\">,</span> <span class=\"mi\">68</span><span class=\"o\">,</span> <span class=\"mi\">73</span><span class=\"o\">,</span> <span class=\"mi\">80</span><span class=\"o\">,</span> <span class=\"mi\">91</span><span class=\"o\">,</span> <span class=\"mi\">96</span><span class=\"o\">,</span> <span class=\"mi\">99</span><span class=\"o\">)</span>\n\n<span class=\"c1\">//xor native</span>\n<span class=\"k\">val</span> <span class=\"n\">xor_nt</span> <span class=\"k\">=</span> <span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"mi\">20</span><span class=\"o\">,</span> <span class=\"mi\">26</span><span class=\"o\">,</span> <span class=\"mi\">28</span><span class=\"o\">,</span> <span class=\"mi\">30</span><span class=\"o\">,</span> <span class=\"mi\">32</span><span class=\"o\">,</span> <span class=\"mi\">34</span><span class=\"o\">,</span> <span class=\"mi\">36</span><span class=\"o\">,</span> <span class=\"mi\">39</span><span class=\"o\">,</span> <span class=\"mi\">41</span><span class=\"o\">,</span> <span class=\"mi\">43</span><span class=\"o\">,</span> <span class=\"mi\">45</span><span class=\"o\">)</span>\n</pre></div>\n\n</div>\n\n<p>The average speedup is:</p>\n\n<div class=\"brush: scala\">\n <div class=\"source\">\n  <pre><span></span><span class=\"o\">(</span><span class=\"n\">xor_ar</span> <span class=\"n\">zip</span> <span class=\"n\">xor_nt</span><span class=\"o\">).</span><span class=\"n\">map</span><span class=\"o\">{</span> <span class=\"k\">case</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">=&gt;</span> <span class=\"mf\">1.0</span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"o\">/</span><span class=\"n\">n</span> <span class=\"o\">}.</span><span class=\"n\">sum</span> <span class=\"o\">/</span> <span class=\"n\">xor_ar</span><span class=\"o\">.</span><span class=\"n\">length</span>\n</pre></div>\n\n</div>\n\n<p>which comes out as <strong>~2x.</strong></p>\n\n<hr />\n\n<p>The full source code can be found <a href=\"https://github.com/billpcs/sdes\">on my github page</a>.</p>\n\n<p><strong>Cheers!</strong></p>"))))